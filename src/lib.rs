//! # Slint for vexide
//!
//! This crate exists to allow for the use of Slint-based UIs in [vexide]. It
//! provides an implementation of the Slint `Platform` trait that uses the V5 brain
//! to render the UI.
//!
//! [vexide]: https://vexide.dev
//!
//! ## Usage
//!
//! To use this crate, add it to your `Cargo.toml`:
//!
//! ```toml
//! [dependencies]
//! slint-vexide = "0.1.0"
//! ```
//!
//! Then, you must call `slint_vexide::initialize_slint_platform()` before creating
//! and running your Slint widget. This will set up Slint for software-rendering
//! your UI on the brain's display.
//!
//! # Example
//!
//! ```no_run
//! // Include the modules generated by Slint for your UI files.
//! // You will need to configure your `build.rs` to do this; see below.
//! slint::include_modules!();
//!
//! #[vexide::main]
//! async fn main(peripherals: vexide::prelude::Peripherals) {
//!     let robot = Robot {
//!         // ...
//!     };
//!
//!     // Since running the Slint UI is a blocking operation, we need to spawn the
//!     // competition task as a separate task that will run concurrently.
//!     // The Slint runtime internally polls all spawned futures.
//!     vexide::task::spawn(robot.compete()).detach();
//!
//!     // Initialize the Slint platform with the V5 display-backed implementation.
//!     vexide_slint::initialize_slint_platform(peripherals.display);
//!     // Create and run the application. For more information on this, see the
//!     // Slint documentation.
//!     MyApplication::new()
//!         .expect("Failed to create application")
//!         .run()
//!         .expect("Failed to run application");
//!     // Since MyApplication::run() could return if the application is closed
//!     // programmatically, we need to convince the compiler that the return type
//!     // is `!` (never).
//!     vexide::program::exit();
//! }
//! ```
//!
//! You'll need to compile your UI code separately from your main application code
//! using a custom build script. Add the `slint-build` crate to your `Cargo.toml`:
//!
//! ```toml
//! [build-dependencies]
//! slint-build = "0.1.0"
//! ```
//!
//! Then, create a `build.rs` file in your project root with the following content:
//!
//! ```no_run
//! fn main() {
//!     // Compile the Slint UI file with the appropriate configuration.
//!     slint_build::compile_with_config(
//!         "ui/YourFile.slint", // Path to your Slint UI file.
//!         slint_build::CompilerConfiguration::new()
//!             // Make sure to enable this configuration flag.
//!             .embed_resources(slint_build::EmbedResourcesKind::EmbedForSoftwareRenderer)
//!             // Optionally, you can specify a style to use for the UI.
//!             // Check the Slint documentation for more information.
//!             .with_style("style-name".into()),
//!     )
//!     .expect("Slint build failed");
//! }
//! ```

#![allow(clippy::needless_doctest_main)] // build script example should contain main function

extern crate alloc;
use alloc::{boxed::Box, rc::Rc};
use core::cell::RefCell;

use slint::{
    platform::{
        software_renderer::{MinimalSoftwareWindow, RepaintBufferType},
        Platform, PointerEventButton, WindowEvent,
    },
    LogicalPosition, PhysicalPosition, PhysicalSize, Rgb8Pixel,
};
use std::time::Instant;
use vexide::display::{Display, Rect, TouchEvent, TouchState};

/// A Slint platform implementation for the V5 Brain screen.
///
/// This struct is a wrapper around a [`Display`] and a [`MinimalSoftwareWindow`]
/// and will handle updates to the screen through the [`Platform`] trait.
pub struct V5Platform {
    start: Instant,
    window: Rc<MinimalSoftwareWindow>,
    last_touch_event: RefCell<Option<TouchEvent>>,
    display: RefCell<Display>,

    buffer: RefCell<
        [Rgb8Pixel;
            Display::HORIZONTAL_RESOLUTION as usize * Display::VERTICAL_RESOLUTION as usize],
    >,
}
impl V5Platform {
    /// Create a new [`V5Platform`] from a [`Display`].
    ///
    /// This is used internally by [`initialize_slint_platform`] to create the
    /// platform.
    #[must_use]
    pub fn new(display: Display) -> Self {
        let window = MinimalSoftwareWindow::new(RepaintBufferType::NewBuffer);
        window.set_size(PhysicalSize::new(
            Display::HORIZONTAL_RESOLUTION as _,
            Display::VERTICAL_RESOLUTION as _,
        ));
        Self {
            start: Instant::now(),
            window,
            display: RefCell::new(display),
            last_touch_event: RefCell::new(None),
            #[allow(clippy::large_stack_arrays)] // we got plenty
            buffer: RefCell::new(
                [Rgb8Pixel::new(0, 0, 0);
                    Display::HORIZONTAL_RESOLUTION as usize * Display::VERTICAL_RESOLUTION as usize],
            ),
        }
    }

    fn get_touch_event(&self) -> Option<WindowEvent> {
        let event = self.display.borrow().touch_status();
        // To avoid dispatching the same event multiple times
        let mut last_event = self.last_touch_event.borrow_mut();
        if Some(event) == *last_event || last_event.is_none() {
            *last_event = Some(event);
            return None;
        }
        let physical_pos = PhysicalPosition::new(event.point.x.into(), event.point.y.into());
        let position = LogicalPosition::from_physical(physical_pos, 1.0);
        let window_event = match event.state {
            TouchState::Released => WindowEvent::PointerReleased {
                position,
                button: PointerEventButton::Left,
            },
            TouchState::Pressed => WindowEvent::PointerPressed {
                position,
                button: PointerEventButton::Left,
            },
            TouchState::Held => WindowEvent::PointerMoved { position },
        };
        *last_event = Some(event);
        Some(window_event)
    }
}

impl Platform for V5Platform {
    fn create_window_adapter(
        &self,
    ) -> Result<alloc::rc::Rc<dyn slint::platform::WindowAdapter>, slint::PlatformError> {
        Ok(self.window.clone())
    }
    fn duration_since_start(&self) -> core::time::Duration {
        self.start.elapsed()
    }
    fn run_event_loop(&self) -> Result<(), slint::PlatformError> {
        loop {
            // Update the Slint timers and animations
            slint::platform::update_timers_and_animations();

            self.window.draw_if_needed(|renderer| {
                // Render the UI to our buffer
                let mut buf = *self.buffer.borrow_mut();
                renderer.render(&mut buf, Display::HORIZONTAL_RESOLUTION as _);

                // Draw the buffer to the screen
                self.display.borrow_mut().draw_buffer(
                    Rect::from_dimensions(
                        [0, 0],
                        Display::HORIZONTAL_RESOLUTION as _,
                        Display::VERTICAL_RESOLUTION as _,
                    ),
                    buf,
                );
            });

            // Connect V5 touch events to Slint
            if let Some(event) = self.get_touch_event() {
                self.window.dispatch_event(event);
            }

            // Hand the CPU back to the scheduler so that user code can run
            // This used to not run if there were any animations running, but
            // it seems to be necessary to run it regardless
            vexide::runtime::block_on(vexide::time::sleep(Display::REFRESH_INTERVAL));
        }
    }
}

/// Sets the Slint platform to [`V5Platform`].
///
/// This function should be called before any other Slint functions are called
/// and lets Slint know that it should use the V5 Brain screen as the platform.
///
/// # Panics
///
/// Panics if the Slint platform is already set (i.e., this function has already
/// been called).
pub fn initialize_slint_platform(display: Display) {
    slint::platform::set_platform(Box::new(V5Platform::new(display)))
        .expect("Slint platform already set!");
}
