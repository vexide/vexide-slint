//! # Slint for vexide
//!
//! This crate exists to allow for the use of Slint-based UIs in [vexide]. It
//! provides an implementation of the Slint `Platform` trait that uses the V5 brain
//! to render the UI.
//!
//! [vexide]: https://vexide.dev
//!
//! ## Usage
//!
//! To use this crate, add it to your `Cargo.toml`:
//!
//! ```toml
//! [dependencies]
//! slint-vexide = "0.1.0"
//! ```
//!
//! Then, you must call `slint_vexide::initialize_slint_platform()` before creating
//! and running your Slint widget. This will set up Slint for software-rendering
//! your UI on the brain's display.
//!
//! # Example
//!
//! ```no_run
//! // Include the modules generated by Slint for your UI files.
//! // You will need to configure your `build.rs` to do this; see below.
//! slint::include_modules!();
//!
//! #[vexide::main]
//! async fn main(peripherals: vexide::prelude::Peripherals) {
//!     let robot = Robot {
//!         // ...
//!     };
//!
//!     // Since running the Slint UI is a blocking operation, we need to spawn the
//!     // competition task as a separate task that will run concurrently.
//!     // The Slint runtime internally polls all spawned futures.
//!     vexide::task::spawn(robot.compete()).detach();
//!
//!     // Initialize the Slint platform with the V5 display-backed implementation.
//!     vexide_slint::initialize_slint_platform(peripherals.display);
//!     // Create and run the application. For more information on this, see the
//!     // Slint documentation.
//!     MyApplication::new()
//!         .expect("Failed to create application")
//!         .run()
//!         .expect("Failed to run application");
//!     // Since MyApplication::run() could return if the application is closed
//!     // programmatically, we need to convince the compiler that the return type
//!     // is `!` (never).
//!     vexide::program::exit();
//! }
//! ```
//!
//! You'll need to compile your UI code separately from your main application code
//! using a custom build script. Add the `slint-build` crate to your `Cargo.toml`:
//!
//! ```toml
//! [build-dependencies]
//! slint-build = "0.1.0"
//! ```
//!
//! Then, create a `build.rs` file in your project root with the following content:
//!
//! ```no_run
//! fn main() {
//!     // Compile the Slint UI file with the appropriate configuration.
//!     slint_build::compile_with_config(
//!         "ui/YourFile.slint", // Path to your Slint UI file.
//!         slint_build::CompilerConfiguration::new()
//!             // Make sure to enable this configuration flag.
//!             .embed_resources(slint_build::EmbedResourcesKind::EmbedForSoftwareRenderer)
//!             // Optionally, you can specify a style to use for the UI.
//!             // Check the Slint documentation for more information.
//!             .with_style("style-name".into()),
//!     )
//!     .expect("Slint build failed");
//! }
//! ```

#![allow(clippy::needless_doctest_main)] // build script example should contain main function

mod target_pixel;

use slint::{
    platform::{
        software_renderer::{MinimalSoftwareWindow, RepaintBufferType, TargetPixel},
        Platform, PointerEventButton, WindowEvent,
    },
    LogicalPosition, PhysicalPosition, PhysicalSize,
};
use std::{cell::RefCell, rc::Rc, time::Instant};
use vexide::display::{Display, Rect, TouchEvent, TouchState};

use crate::target_pixel::ColorPixel;

/// A Slint platform implementation for the V5 Brain screen.
///
/// This struct is a wrapper around a [`Display`] and a [`MinimalSoftwareWindow`]
/// and will handle updates to the screen through the [`Platform`] trait.
pub struct V5Platform {
    start: Instant,
    window: Rc<MinimalSoftwareWindow>,
    last_touch_event: RefCell<Option<TouchEvent>>,
    display: RefCell<Display>,

    buffer: RefCell<
        [ColorPixel;
            Display::HORIZONTAL_RESOLUTION as usize * Display::VERTICAL_RESOLUTION as usize],
    >,
}
impl V5Platform {
    /// Create a new [`V5Platform`] from a [`Display`].
    ///
    /// This is used internally by [`initialize_slint_platform`] to create the
    /// platform.
    #[must_use]
    pub fn new(display: Display) -> Self {
        let window = MinimalSoftwareWindow::new(RepaintBufferType::NewBuffer);
        window.set_size(PhysicalSize::new(
            Display::HORIZONTAL_RESOLUTION as _,
            Display::VERTICAL_RESOLUTION as _,
        ));
        Self {
            start: Instant::now(),
            window,
            display: RefCell::new(display),
            last_touch_event: RefCell::new(None),
            #[allow(clippy::large_stack_arrays)] // we got plenty
            buffer: RefCell::new(
                [ColorPixel::background();
                    Display::HORIZONTAL_RESOLUTION as usize * Display::VERTICAL_RESOLUTION as usize],
            ),
        }
    }

    fn get_touch_event(&self) -> Option<WindowEvent> {
        let event = self.display.borrow().touch_status();
        // To avoid dispatching the same event multiple times
        let mut last_event = self.last_touch_event.borrow_mut();
        if Some(event) == *last_event || last_event.is_none() {
            *last_event = Some(event);
            return None;
        }
        let physical_pos = PhysicalPosition::new(event.point.x.into(), event.point.y.into());
        let position = LogicalPosition::from_physical(physical_pos, 1.0);
        let window_event = match event.state {
            TouchState::Released => WindowEvent::PointerReleased {
                position,
                button: PointerEventButton::Left,
            },
            TouchState::Pressed => WindowEvent::PointerPressed {
                position,
                button: PointerEventButton::Left,
            },
            TouchState::Held => WindowEvent::PointerMoved { position },
        };
        *last_event = Some(event);
        Some(window_event)
    }
}

impl Platform for V5Platform {
    fn create_window_adapter(
        &self,
    ) -> Result<Rc<dyn slint::platform::WindowAdapter>, slint::PlatformError> {
        Ok(self.window.clone())
    }
    fn duration_since_start(&self) -> core::time::Duration {
        self.start.elapsed()
    }
    fn run_event_loop(&self) -> Result<(), slint::PlatformError> {
        loop {
            // Update the Slint timers and animations
            slint::platform::update_timers_and_animations();

            self.window.draw_if_needed(|renderer| {
                // Render the UI to our buffer
                let mut buf = *self.buffer.borrow_mut();
                // Currently, Slint does not actually diff the regions and just
                // passes the entire screen as dirty, but for future-proofing we
                // still handle the dirty regions properly.
                let dirty_regions = renderer.render(&mut buf, Display::HORIZONTAL_RESOLUTION as _);

                let buf = 
                    // SAFETY: The buffer is a valid slice of ColorPixel, which
                    // is guaranteed to have the same size and alignment as Color
                    // (being a newtype).
                    // In turn, Color is guaranteed to be a valid representation
                    // of a u32 in BGR0 format.
                    bytemuck::cast_slice_mut::<ColorPixel, u32>(&mut buf);
                for (position, size) in dirty_regions.iter() {
                    // Convert the dirty region to a Rect
                    let region = Rect::from_dimensions(
                        [position.x as _, position.y as _],
                        size.width as _,
                        size.height as _,
                    );

                    // Draw the dirty region to the buffer
                    // SAFETY: We have ownership of the display.
                    unsafe {
                        vex_sdk::vexDisplayCopyRect(
                            i32::from(region.top_left.x),
                            i32::from(region.top_left.y),
                            i32::from(region.bottom_right.x - 1),
                            i32::from(region.bottom_right.y - 1),
                            buf.as_ptr().cast_mut(),
                            i32::from(
                                Display::HORIZONTAL_RESOLUTION,
                            ),
                        );
                    }
                }
            });

            // Connect V5 touch events to Slint
            if let Some(event) = self.get_touch_event() {
                self.window.dispatch_event(event);
            }

            // Hand the CPU back to the scheduler so that user code can run
            // This used to not run if there were any animations running, but
            // it seems to be necessary to run it regardless
            vexide::runtime::block_on(vexide::time::sleep(Display::REFRESH_INTERVAL));
        }
    }
}

/// Sets the Slint platform to [`V5Platform`].
///
/// This function should be called before any other Slint functions are called
/// and lets Slint know that it should use the V5 Brain screen as the platform.
///
/// # Panics
///
/// Panics if the Slint platform is already set (i.e., this function has already
/// been called).
pub fn initialize_slint_platform(display: Display) {
    slint::platform::set_platform(Box::new(V5Platform::new(display)))
        .expect("Slint platform already set!");
}
